/**
 * Copyright (c) Tony Givargis, 2020-2025
 *
 * s_lang_lexer.h
 */

#ifndef _S_LANG_LEXER_H_
#define _S_LANG_LEXER_H_

#include "../utils/s_utils.h"

enum {
	S__LANG_LEXER_,
	S__LANG_LEXER_EOF,
	S__LANG_LEXER_INT,
	S__LANG_LEXER_UINT,
	S__LANG_LEXER_REAL,
	S__LANG_LEXER_CHAR,
	S__LANG_LEXER_STRING,
	S__LANG_LEXER_IDENTIFIER,
	/*-*/
	S__LANG_LEXER_KEYWORD_,
	S__LANG_LEXER_KEYWORD_AUTO,
	S__LANG_LEXER_KEYWORD_BREAK,
	S__LANG_LEXER_KEYWORD_CASE,
	S__LANG_LEXER_KEYWORD_CHAR,
	S__LANG_LEXER_KEYWORD_CONST,
	S__LANG_LEXER_KEYWORD_CONTINUE,
	S__LANG_LEXER_KEYWORD_DEFAULT,
	S__LANG_LEXER_KEYWORD_DO,
	S__LANG_LEXER_KEYWORD_DOUBLE,
	S__LANG_LEXER_KEYWORD_ELSE,
	S__LANG_LEXER_KEYWORD_ENUM,
	S__LANG_LEXER_KEYWORD_EXTERN,
	S__LANG_LEXER_KEYWORD_FLOAT,
	S__LANG_LEXER_KEYWORD_FOR,
	S__LANG_LEXER_KEYWORD_GOTO,
	S__LANG_LEXER_KEYWORD_IF,
	S__LANG_LEXER_KEYWORD_INT,
	S__LANG_LEXER_KEYWORD_LONG,
	S__LANG_LEXER_KEYWORD_REGISTER,
	S__LANG_LEXER_KEYWORD_RETURN,
	S__LANG_LEXER_KEYWORD_SHORT,
	S__LANG_LEXER_KEYWORD_SIGNED,
	S__LANG_LEXER_KEYWORD_SIZEOF,
	S__LANG_LEXER_KEYWORD_STATIC,
	S__LANG_LEXER_KEYWORD_STRUCT,
	S__LANG_LEXER_KEYWORD_SWITCH,
	S__LANG_LEXER_KEYWORD_TYPEDEF,
	S__LANG_LEXER_KEYWORD_UNION,
	S__LANG_LEXER_KEYWORD_UNSIGNED,
	S__LANG_LEXER_KEYWORD_VOID,
	S__LANG_LEXER_KEYWORD_VOLATILE,
	S__LANG_LEXER_KEYWORD_WHILE,
	/*-*/
	S__LANG_LEXER_OPERATOR_,
	S__LANG_LEXER_OPERATOR_ADD,
	S__LANG_LEXER_OPERATOR_SUB,
	S__LANG_LEXER_OPERATOR_MUL,
	S__LANG_LEXER_OPERATOR_DIV,
	S__LANG_LEXER_OPERATOR_MOD,
	S__LANG_LEXER_OPERATOR_SHL,
	S__LANG_LEXER_OPERATOR_SHR,
	S__LANG_LEXER_OPERATOR_OR,
	S__LANG_LEXER_OPERATOR_XOR,
	S__LANG_LEXER_OPERATOR_AND,
	S__LANG_LEXER_OPERATOR_NOT,
	S__LANG_LEXER_OPERATOR_LOGIC_OR,
	S__LANG_LEXER_OPERATOR_LOGIC_AND,
	S__LANG_LEXER_OPERATOR_LOGIC_NOT,
	S__LANG_LEXER_OPERATOR_INC,
	S__LANG_LEXER_OPERATOR_DEC,
	S__LANG_LEXER_OPERATOR_LT,
	S__LANG_LEXER_OPERATOR_GT,
	S__LANG_LEXER_OPERATOR_LE,
	S__LANG_LEXER_OPERATOR_GE,
	S__LANG_LEXER_OPERATOR_EQ,
	S__LANG_LEXER_OPERATOR_NE,
	S__LANG_LEXER_OPERATOR_ADDASN,
	S__LANG_LEXER_OPERATOR_SUBASN,
	S__LANG_LEXER_OPERATOR_MULASN,
	S__LANG_LEXER_OPERATOR_DIVASN,
	S__LANG_LEXER_OPERATOR_MODASN,
	S__LANG_LEXER_OPERATOR_SHLASN,
	S__LANG_LEXER_OPERATOR_SHRASN,
	S__LANG_LEXER_OPERATOR_ORASN,
	S__LANG_LEXER_OPERATOR_XORASN,
	S__LANG_LEXER_OPERATOR_ANDASN,
	S__LANG_LEXER_OPERATOR_ASN,
	S__LANG_LEXER_OPERATOR_OPEN_BRACE,
	S__LANG_LEXER_OPERATOR_CLOSE_BRACE,
	S__LANG_LEXER_OPERATOR_OPEN_PARENTH,
	S__LANG_LEXER_OPERATOR_CLOSE_PARENTH,
	S__LANG_LEXER_OPERATOR_OPEN_BRACKET,
	S__LANG_LEXER_OPERATOR_CLOSE_BRACKET,
	S__LANG_LEXER_OPERATOR_DOT,
	S__LANG_LEXER_OPERATOR_COMMA,
	S__LANG_LEXER_OPERATOR_COLON,
	S__LANG_LEXER_OPERATOR_POINTER,
	S__LANG_LEXER_OPERATOR_QUESTION,
	S__LANG_LEXER_OPERATOR_SEMICOLON,
	S__LANG_LEXER_OPERATOR_DOTDOTDOT
};

struct s__lang_lexer_token {
	int op;
	uint64_t lineno;
	uint64_t column;
	union {
		int c;               /* S__LANG_LEXER_CHAR */
		double r;            /* S__LANG_LEXER_REAL */
		const char *s;       /* S__LANG_LEXER_STRING/IDENTIFIER */
		struct s__int256 i;  /* S__LANG_LEXER_INT */
		struct s__uint256 u; /* S__LANG_LEXER_UINT */
	} u;
};

typedef struct s__lang_lexer *s__lang_lexer_t;

s__lang_lexer_t s__lang_lexer_open(const char *pathname);

void s__lang_lexer_close(s__lang_lexer_t lexer);

const struct s__lang_lexer_token *
s__lang_lexer_lookup(s__lang_lexer_t lexer, uint64_t i);

uint64_t s__lang_lexer_size(s__lang_lexer_t lexer);

const char *s__lang_lexer_pathname(s__lang_lexer_t lexer);

#endif /* _S_LANG_LEXER_H_ */
